# Other Functions and Variables

This page lists and documents various miscellaneous functions and variables not better listed somewhere else.

## Ren'Py Version

renpy.version(_tuple\=False_)

If tuple is false, returns a string containing "Ren'Py ", followed by the current version of Ren'Py.

If tuple is true, returns a tuple giving each component of the version as an integer.

renpy.version\_string

The version number of Ren'Py, as a string of the form "Ren'Py 1.2.3.456".

renpy.version\_only

The version number of Ren'Py, without the Ren'Py prefix. A string of the form "1.2.3.456".

renpy.version\_tuple

The version number of Ren'Py, as a tuple of the form (1, 2, 3, 456).

This is a namedtuple with four fields: `major`, `minor`, `patch`, and `commit`.

renpy.version\_name

A human readable version name, of the form "Example Version."

renpy.license

A string giving license text that should be included in a game's about screen.

## Platform Detection

Ren'Py includes a number of variables that are set based on which platform it's running on.

renpy.windows

Has a true value when running on Windows.

renpy.macintosh

Has a true value when running on macOS.

renpy.linux

Has a true value when running on Linux or other POSIX-like operating systems.

renpy.android

Has a true value when running on Android.

renpy.ios

Has a true value when running on iOS.

renpy.emscripten

Has a true value when running in the browser.

renpy.mobile

Has a true value when running on Android or iOS or in the browser.

These are only set when running on the actual devices, not when running on in the emulators. These are more intended for use in platform-specific Python. For display layout, use .

## Memory Profiling

renpy.diff\_memory(_update\=True_, _skip\_constants\=False_)

Profiles objects, surface, and texture memory use by Ren'Py and the game. Writes (to memory.txt and stdout) the difference in memory usage from the last time this function was called with update true.

The accounting is by names in the store and in the Ren'Py implementation that the memory is reachable from. If an object is reachable from more than one name, it's assigned to the name it's most directly reachable from.

skip\_constants

If True, the profiler will skip scanning of large Ren'Py's containers, that are intended to be immutable after startup.

As it has to scan all memory used by Ren'Py, this function may take a long time to complete.

renpy.profile\_memory(_fraction\=1.0_, _minimum\=0_, _skip\_constants\=False_)

Profiles object, surface, and texture memory use by Ren'Py and the game. Writes an accounting of memory use by to the memory.txt file and stdout.

The accounting is by names in the store and in the Ren'Py implementation that the memory is reachable from. If an object is reachable from more than one name, it's assigned to the name it's most directly reachable from.

fraction

The fraction of the total memory usage to show. 1.0 will show all memory usage, .9 will show the top 90%.

minimum

If a name is accounted less than minimum bytes of memory, it will not be printed.

skip\_constants

If True, the profiler will skip scanning of large Ren'Py's containers, that are intended to be immutable after startup.

As it has to scan all memory used by Ren'Py, this function may take a long time to complete.

renpy.profile\_rollback()

Profiles memory used by the rollback system. Writes (to memory.txt and stdout) the memory used by the rollback system. This tries to account for rollback memory used by various store variables, as well as by internal aspects of the rollback system.

## renpy.random

This object is a random number generator that implements . Randomness can be generated by calling the various methods this object exposes. See the Python documentation for the full list, but the most useful are:

*   `renpy.random.random()`
    

Return the next random floating point number in the range (0.0, 1.0).

*   `renpy.random.randint(a, b)`
    

Return a random integer such that a <= N <= b.

*   `renpy.random.choice(seq)`
    

Return a random element from the non-empty sequence seq.

*   `renpy.random.shuffle(seq)`
    

Shuffles the elements of the sequence seq in place. This does not return a list, but changes an existing one.

Unlike the standard Python random number generator, this object cooperates with rollback, generating the same numbers regardless of how many times we rollback. It should be used instead of the standard Python random module.

\# return a random float between 0 and 1
$ randfloat \= renpy.random.random()

\# return a random integer between 1 and 20
$ d20roll \= renpy.random.randint(1, 20)

\# return a random element from a list
$ randfruit \= renpy.random.choice(\['apple', 'orange', 'plum'\])

*   `renpy.random.Random(seed=None)`
    

Returns a new random number generator object separate from the main one, seeded with the specified value if provided.

## SDL

The SDL2 dll can be accessed using . This allows the use of SDL2 functions directly. However, using them often requires knowledge of the Python ctypes module.

There are no guarantees as to the version of SDL2 that's included with Ren'Py, including which features will or will not be compiled in. These functions may fail on platforms that can otherwise run Ren'Py. It's important to check for a None value before proceeding.

In the following example, the position of the window will be taken from SDL2:

init python:

    import ctypes

    def get\_window\_position():
        """Retrieves the position of the window from SDL2.

        Returns the (x, y) of the upper left corner of the window, or
        (0, 0) if it's not known.
        """

        sdl \= renpy.get\_sdl\_dll()

        if sdl is None:
            return (0, 0)

        win \= renpy.get\_sdl\_window\_pointer()

        if win is None:
            return (0, 0)

        x \= ctypes.c\_int()
        y \= ctypes.c\_int()

        result \= sdl.SDL\_GetWindowPosition(win, ctypes.byref(x), ctypes.byref(y))

        return result

renpy.get\_sdl\_dll()

Returns a ctypes.cdll object that refers to the library that contains the instance of SDL2 that Ren'Py is using. If this fails, None is returned.

renpy.get\_sdl\_window\_pointer()

Return type:

ctypes.c\_void\_p | None

Returns a pointer to the main window, or None if the main window is not displayed (or some other problem occurs).

## Miscellaneous

renpy.add\_python\_directory(_path_)

Adds path to the list of paths searched for Python modules and packages. The path should be a string relative to the game directory. This must be called before an import statement.

renpy.add\_to\_all\_stores(_name_, _value_)

Adds the value by the name to all creator defined namespaces. If the name already exist in that namespace - do nothing for it.

This function may only be run from inside an init block. It is an error to run this function once the game has started.

renpy.can\_fullscreen()

Returns True if the current platform supports fullscreen mode, False otherwise.

renpy.capture\_focus(_name\='default'_)

If a displayable is currently focused, captured the rectangular bounding box of that displayable, and stores it with name. If not, removes any focus stored with name.

Captured focuses are not saved when the game is saveed.

name

Should be a string. The name "tooltip" is special, as it's automatically captured when a displayable with a tooltip gains focus.

renpy.choice\_for\_skipping()

Tells Ren'Py that a choice is coming up soon. This currently has two effects:

*   If Ren'Py is skipping, and the Skip After Choices preferences is set to stop skipping, skipping is terminated.
    
*   An auto-save is triggered.
    

renpy.clear\_capture\_focus(_name\='default'_)

Clear the captured focus with name. If name is None, clear all captured focuses.

renpy.clear\_game\_runtime()

Resets the game runtime counter.

renpy.clear\_retain(_layer\='screens'_, _prefix\='\_retain'_)

Clears all retained screens

renpy.confirm(_message_)

This causes the a yes/no prompt screen with the given message to be displayed, and dismissed when the player hits yes or no.

Returns True if the player hits yes, and False if the player hits no.

message

The message that will be displayed.

See  for a similar Action.

renpy.count\_dialogue\_blocks()

Returns the number of dialogue blocks in the game's original language.

renpy.count\_newly\_seen\_dialogue\_blocks()

Returns the number of dialogue blocks the user has seen for the first time during this session.

renpy.count\_seen\_dialogue\_blocks()

Returns the number of dialogue blocks the user has seen in any play-through of the current game.

renpy.display\_notify(_message_)

The default implementation of .

renpy.focus\_coordinates()

This attempts to find the coordinates of the currently-focused displayable. If it can, it will return them as a (x, y, w, h) tuple. If not, it will return a (None, None, None, None) tuple.

renpy.force\_autosave(_take\_screenshot\=False_, _block\=False_)

Forces a background autosave to occur.

take\_screenshot

If True, a new screenshot will be taken. If False, the existing screenshot will be used.

block

If True, blocks until the autosave completes.

renpy.free\_memory()

Attempts to free some memory. Useful before running a renpygame-based minigame.

renpy.full\_restart(_transition\=False_, _\*_, _save\=False_)

Causes Ren'Py to restart, returning the user to the main menu.

transition

If given, the transition to run, or None to not run a transition. False uses .

save

If true, the game is saved in  before Ren'Py restarts and returns the user to the main menu.

renpy.get\_game\_runtime()

Returns the game runtime counter.

The game runtime counter counts the number of seconds that have elapsed while waiting for user input in the top-level context. (It does not count time spent in the main or game menus.)

renpy.get\_image\_load\_log(_age\=None_)

A generator that yields a log of image loading activity. For the last 100 image loads, this returns:

*   The time the image was loaded (in seconds since the epoch).
    
*   The filename of the image that was loaded.
    
*   A boolean that is true if the image was preloaded, and false if the game stalled to load it.
    

The entries are ordered from newest to oldest.

age

If not None, only images that have been loaded in the past age seconds are included.

The image load log is only kept if config.developer = True.

renpy.get\_menu\_args()

Returns a tuple giving the arguments (as a tuple) and the keyword arguments (as a dict) passed to the current menu statement.

renpy.get\_mouse\_name(_interaction\=False_)

Returns the name of the mouse that should be shown.

interaction

If true, get a mouse name that is based on the type of interaction occuring. (This is rarely useful.)

renpy.get\_mouse\_pos()

Returns an (x, y) tuple giving the location of the mouse pointer or the current touch location. If the device does not support a mouse and is not currently being touched, x and y are numbers, but not meaningful.

renpy.get\_on\_battery()

Returns True if Ren'Py is running on a device that is powered by an internal battery, or False if the device is being charged by some external source.

renpy.get\_ongoing\_transition(_layer\=None_)

Returns the transition that is currently ongoing.

layer

If None, the top-level transition is returned. Otherwise, this should be a string giving a layer name, in which case the transition for that layer is returned.

renpy.get\_physical\_size()

Returns the size of the physical window.

renpy.get\_refresh\_rate(_precision\=5_)

Returns the refresh rate of the current screen, as a floating-point number of frames per second.

precision

The raw data Ren'Py gets is the number of frames per second rounded down to the nearest integer. This means that a monitor that runs at 59.95 frames per second will be reported at 59 fps. The precision argument then further reduces the precision of this reading, such that the only valid readings are multiples of the precision.

Since all monitor framerates tend to be multiples of 5 (25, 30, 60, 75, and 120), this likely will improve accuracy. Setting precision to 1 disables this.

renpy.get\_renderer\_info()

Returns a dictionary, giving information about the renderer Ren'Py is currently using. Defined keys are:

`"renderer"`

A string giving the name of the renderer that is in use.

`"resizable"`

True if and only if the window is resizable.

`"additive"`

True if and only if the renderer supports additive blending.

`"model"`

Present and true if model-based rendering is supported.

Other, renderer-specific, keys may also exist. The dictionary should be treated as immutable. This should only be called once the display has been started (that is, after the init phase has finished).

renpy.get\_say\_attributes()

Gets the attributes associated with the current say statement, or None if no attributes are associated with this statement.

This is only valid when executing or predicting a say statement.

renpy.get\_skipping()

Returns "slow" if the Ren'Py is skipping, "fast" if Ren'Py is fast skipping, and None if it is not skipping.

renpy.get\_statement\_name()

Get the name of the current statement, a string like "say", "say-nvl", or "window hide". This is the same statement name used with .

renpy.get\_transition(_layer\=None_)

Gets the transition for layer, or the entire scene if layer is None. This returns the transition that is queued up to run during the next interaction, or None if no such transition exists.

Use  to get the transition that is in progress.

renpy.iconify()

Iconifies the game.

renpy.include\_module(_name_)

Similar to , but instead of loading the module right away, inserts it into the init queue somewhere after the current AST node.

The module may not contain init blocks lower than the block that includes the module. For example, if your module contains an init 10 block, the latest you can load it is init 10.

Module loading may only occur from inside an init block.

renpy.invoke\_in\_main\_thread(_fn_, _\*args_, _\*\*kwargs_)

This runs the given function with the given arguments in the main thread. The function runs in an interaction context similar to an event handler. This is meant to be called from a separate thread, whose creation is handled by .

If a single thread schedules multiple functions to be invoked, it is guaranteed that they will be run in the order in which they have been scheduled:

def ran\_in\_a\_thread():
    renpy.invoke\_in\_main\_thread(a)
    renpy.invoke\_in\_main\_thread(b)

In this example, it is guaranteed that `a` will return before `b` is called. The order of calls made from different threads is not guaranteed.

This may not be called during the init phase.

renpy.invoke\_in\_thread(_fn_, _\*args_, _\*\*kwargs_)

Invokes the function fn in a background thread, passing it the provided arguments and keyword arguments. Restarts the interaction once the thread returns.

This function creates a daemon thread, which will be automatically stopped when Ren'Py is shutting down.

This thread is very limited in what it can do with the Ren'Py API. Changing store variables is allowed, as are calling calling the following functions:

*   
    
*   
    
*   
    

Most other portions of the Ren'Py API are expected to be called from the main thread.

This does not work on the web platform, except for immediately returning without an error.

renpy.is\_init\_phase()

Returns True if Ren'Py is currently executing init code, or False otherwise.

renpy.is\_mouse\_visible()

Returns True if the mouse cursor is visible, False otherwise.

renpy.is\_seen(_ever\=True_)

Returns true if the current line has been seen by the player.

If ever is true, we check to see if the line has ever been seen by the player. If false, we check if the line has been seen in the current play-through.

renpy.is\_skipping()

Returns True if Ren'Py is currently skipping (in fast or slow skip mode), or False otherwise.

renpy.is\_start\_interact()

Returns true if restart\_interaction has not been called during the current interaction. This can be used to determine if the interaction is just being started, or has been restarted.

renpy.language\_tailor(_chars_, _cls_)

This can be used to override the line breaking class of a unicode character. For example, the linebreaking class of a character can be set to ID to treat it as an ideograph, which allows breaks before and after that character.

chars

A string containing each of the characters to tailor.

cls

A string giving a character class. This should be one of the classes defined in Table 1 of .

renpy.last\_say()

Returns an object containing information about the last say statement.

While this can be called during a say statement, if the say statement is using a normal Character, the information will be about the _current_ say statement, instead of the preceding one.

who

The speaker. This is usually a  object, but this is not required.

what

A string with the dialogue spoken. This may be None if dialogue hasn't been shown yet, for example at the start of the game.

args

A tuple of arguments passed to the last say statement.

kwargs

A dictionary of keyword arguments passed to the last say statement.

Warning

Like other similar functions, the object this returns is meant to be used in the short term after the function is called. Including it in save data or making it participate in rollback is not advised.

renpy.load\_module(_name_)

This loads the Ren'Py module named name. A Ren'Py module consists of Ren'Py script that is loaded into the usual (store) namespace, contained in a file named name.rpym or name.rpymc. If a .rpym file exists, and is newer than the corresponding .rpymc file, it is loaded and a new .rpymc file is created.

All of the init blocks (and other init-phase code) in the module are run before this function returns. An error is raised if the module name cannot be found, or is ambiguous.

Module loading may only occur from inside an init block.

renpy.load\_string(_s_, _filename\='<string>'_)

Loads s as Ren'Py script that can be called.

Returns the name of the first statement in s.

filename is the name of the filename that statements in the string will appear to be from.

renpy.maximum\_framerate(_t_)

Forces Ren'Py to draw the screen at the maximum framerate for t seconds. If t is None, cancels the maximum framerate request.

renpy.munge(_name_, _filename\=None_)

Munges name, which must begin with \_\_.

filename

The filename the name is munged into. If None, the name is munged into the filename containing the call to this function.

renpy.not\_infinite\_loop(_delay_)

Resets the infinite loop detection timer to delay seconds.

renpy.notify(_message_)

Causes Ren'Py to display the message using the notify screen. By default, this will cause the message to be dissolved in, displayed for two seconds, and dissolved out again.

This is useful for actions that otherwise wouldn't produce feedback, like screenshots or quicksaves.

Only one notification is displayed at a time. If a second notification is displayed, the first notification is replaced.

This function just calls , allowing its implementation to be replaced by assigning a new function to that variable.

renpy.open\_url(_url_)

Opens a URL in the system's web browser, if possible.

renpy.predicting()

Returns true if Ren'Py is currently in a predicting phase.

renpy.queue\_event(_name_, _up\=False_, _\*\*kwargs_)

Queues an event with the given name. Name should be one of the event names in , or a list of such names.

up

This should be false when the event begins (for example, when a keyboard button is pressed.) It should be true when the event ends (when the button is released.)

The event is queued at the time this function is called. This function will not work to replace an event with another - doing so will change event order. (Use  instead.)

This method is threadsafe.

renpy.quit(_relaunch\=False_, _status\=0_, _save\=False_)

This causes Ren'Py to exit entirely.

relaunch

If true, Ren'Py will run a second copy of itself before quitting.

status

The status code Ren'Py will return to the operating system. Generally, 0 is success, and positive integers are failure.

save

If true, the game is saved in  before Ren'Py terminates.

renpy.quit\_event()

Triggers a quit event, as if the player clicked the quit button in the window chrome.

renpy.reset\_physical\_size()

Attempts to set the size of the physical window to the size specified using `renpy.config.physical_height` and `renpy.config.physical_width`, or the size set using `renpy.config.screen_width` and `renpy.config.screen_height` if not set.

renpy.restart\_interaction()

Restarts the current interaction. Among other things, this displays images added to the scene, re-evaluates screens, and starts any queued transitions.

This only does anything when called from within an interaction (for example, from an action). Outside an interaction, this function has no effect.

renpy.scry()

Returns the scry object for the current statement. Returns None if there are no statements executing.

The scry object tells Ren'Py about things that must be true in the future of the current statement. Right now, the scry object has the following fields:

nvl\_clear

Is true if an `nvl clear` statement will execute before the next interaction.

say

Is true if an `say` statement will execute before the next interaction.

menu\_with\_caption

Is true if a `menu` statement with a caption will execute before the next interaction.

who

If a `say` or `menu-with-caption` statement will execute before the next interaction, this is the character object it will use.

The scry object has a next() method, which returns the scry object of the statement after the current one, if only one statement will execute after the this one. Otherwise, it returns None.

Warning

Like other similar functions, the object this returns is meant to be used in the short term after the function is called. Including it in save data or making it participate in rollback is not advised.

renpy.set\_mouse\_pos(_x_, _y_, _duration\=0_)

Jump the mouse pointer to the location given by arguments x and y. If the device does not have a mouse pointer, this does nothing.

duration

The time it will take to perform the move, in seconds. During this time, the mouse may be unresponsive.

renpy.set\_physical\_size(_size_)

Attempts to set the size of the physical window to size. This has the side effect of taking the screen out of fullscreen mode.

renpy.shown\_window()

Call this to indicate that the window has been shown. This interacts with the "window show" statement, which shows an empty window whenever this functions has not been called during an interaction.

renpy.split\_properties(_properties_, _\*prefixes_)

Splits up properties into multiple dictionaries, one per prefix. This function checks each key in properties against each prefix, in turn. When a prefix matches, the prefix is stripped from the key, and the resulting key is mapped to the value in the corresponding dictionary.

If no prefix matches, an exception is thrown. (The empty string, "", can be used as the last prefix to create a catch-all dictionary.)

For example, this splits properties beginning with text from those that do not:

text\_properties, button\_properties \= renpy.split\_properties(properties, "text\_", "")

renpy.stop\_skipping()

Stops skipping, if Ren'Py is currently skipping.

renpy.transition(_trans_, _layer\=None_, _always\=False_)

Sets the transition that will be used during the next interaction.

layer

The layer the transition applies to. If None, the transition applies to the entire scene.

always

If false, this respects the transition preference. If true, the transition is always run.

renpy.vibrate(_duration_)

Causes the device to vibrate for duration seconds. Currently, this is only supported on Android.
